/*
 * Copyright (C) 2009-2017 Lightbend Inc. <https://www.lightbend.com>
 */
package play.mvc;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Stack;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * Defines a 'call', describing an HTTP request. For example used to create links or populate redirect data.
 * <p>
 * These values are usually generated by the reverse router.
 */
public abstract class Call {

    private static java.util.Random rand = new java.util.Random();

    /**
     * The request URL.
     *
     * @return the url
     */
    public abstract String url();

    /**
     * The request HTTP method.
     *
     * @return the http method (e.g. "GET")
     */
    public abstract String method();

    /**
     * The fragment of the URL.
     *
     * @return the fragment (without leading '#' character)
     */
    public abstract String fragment();

    /**
     * Append a unique identifier to the URL.
     *
     * @return a copy if this call with a unique identifier to this url
     */
    public Call unique() {
        return new play.api.mvc.Call(method(), this.uniquify(this.url()), fragment());
    }

    protected final String uniquify(String url) {
        return url + ((url.indexOf('?') == -1) ? "?" : "&") + rand.nextLong();
    }

    /**
     * Returns a new Call with the given fragment.
     *
     * @param fragment the URL fragment
     * @return a copy of this call that contains the fragment
     */
    public Call withFragment(String fragment) {
        return new play.api.mvc.Call(method(), url(), fragment);
    }

    /**
     * Returns the fragment (including the leading "#") if this call has one.
     *
     * @return the fragment, with leading "#"
     */
    protected String appendFragment() {
        if (this.fragment() != null && !this.fragment().trim().isEmpty()) {
            return "#" + this.fragment();
        } else {
            return "";
        }
    }

    /**
     * Transform this call to an absolute URL.
     *
     * @param request used to identify the host and protocol that should base this absolute URL
     * @return the absolute URL string
     */
    public String absoluteURL(Http.Request request) {
        return absoluteURL(request.secure(), request.host());
    }

    /**
     * Transform this call to an absolute URL.
     *
     * @param request used to identify the host that should base this absolute URL
     * @param secure true if the absolute URL should use HTTPS protocol
     * @return the absolute URL string
     */
    public String absoluteURL(Http.Request request, boolean secure) {
        return absoluteURL(secure, request.host());
    }

    /**
     * Transform this call to an absolute URL.
     *
     * @param secure true if the absolute URL should use HTTPS protocol instead of HTTP
     * @param host the absolute URL's domain
     * @return the absolute URL string
     */
    public String absoluteURL(boolean secure, String host) {
        return "http" + (secure ? "s" : "") + "://" + host + this.url() + this.appendFragment();
    }

    /**
     * Transform this call to an WebSocket URL.
     *
     * @param request used as the base for forming the WS url
     * @return the websocket url string
     */
    public String webSocketURL(Http.Request request) {
        return webSocketURL(request.secure(), request.host());
    }

    /**
     * Transform this call to an WebSocket URL.
     *
     * @param request used to identify the host for the absolute URL
     * @param secure true if it should be a wss rather than ws URL
     * @return the websocket URL string
     */
    public String webSocketURL(Http.Request request, boolean secure) {
      return webSocketURL(secure, request.host());
    }

    /**
     * Transform this call to an WebSocket URL.
     *
     * @param host the host for the absolute URL.
     * @param secure true if it should be a wss rather than ws URL
     * @return the url string
     */
    public String webSocketURL(boolean secure, String host) {
      return "ws" + (secure ? "s" : "") + "://" + host + this.url();
    }

    private static String CURDIR = ".";
    private static String SEP = "/";
    private static String PARDIR = "..";

    /**
     * Transform this call to a relative path.
     * @param requestHeader used to identify the current depth for the requested URL.
     * @return the relative path string
     */
    public String relative(Http.RequestHeader requestHeader) {
        return relative(requestHeader.path());
    }

    protected String relative(String startPath) {
        // If the start and Call.url are the same then link to the current directory
        if (startPath.equals(this.url())) {
            return CURDIR + this.appendFragment();
        }

        String[] start = toSegments(canonical(startPath));
        String[] target = toSegments(canonical());

        // If start path has no trailing separator (a "file" path), then drop file segment
        if (!startPath.endsWith(SEP)) {
            start = Arrays.copyOfRange(start, 0, start.length - 1);
        }

        // If target path has no trailing separator, then drop file segment, but keep a reference to add it later
        String targetFile = "";
        if (!this.url().endsWith(SEP)) {
            targetFile = target[target.length-1];
            target = Arrays.copyOfRange(target, 0, target.length - 1);
        }

        // Work out how much of the filepath is shared by start and path.
        String[] common = commonPrefix(start, target);
        String[] parents = toParentDirs(start.length - common.length);

        int relativeStartIdx = common.length;
        String[] relativeDirs = Arrays.copyOfRange(target, relativeStartIdx, target.length);
        String[] relativePath = Arrays.copyOf(parents, parents.length + relativeDirs.length);
        System.arraycopy(relativeDirs, 0, relativePath, parents.length, relativeDirs.length);

        // If this is not a sibling reference append a trailing / to path
        String trailingSep = "";
        if (relativePath.length > 0) {
            trailingSep = SEP;
        }

        return Arrays.stream(relativePath).collect(Collectors.joining(SEP)) + trailingSep + targetFile + this.appendFragment();
    }

    /**
     * Transform this path into its canonical form.
     * @return The canonical path.
     */
    public String canonical() {
        return canonical(this.url());
    }

    private String canonical(String url) {
        String[] urlPath = toSegments(url);
        Stack<String> canonical = new Stack<>();
        for (String comp : urlPath) {
            if (comp.equals("") || comp.equals(CURDIR)) {
                continue;
            }
            if (!comp.equals(PARDIR) || (!canonical.empty() && canonical.peek().equals(PARDIR))) {
                canonical.push(comp);
            } else {
                canonical.pop();
            }
        }

        String prefixSep = url.startsWith(SEP) ? SEP : "";
        String trailingSep = url.endsWith(SEP) ? SEP : "";

        return prefixSep + canonical.stream().collect(Collectors.joining(SEP)) + trailingSep + this.appendFragment();
    }

    private String[] toSegments(String url) {
        return Arrays
                .stream(url.split(SEP))
                .filter(s -> !s.isEmpty()).toArray(String[]::new);
    }

    private String[] toParentDirs(int count) {
        return IntStream
                .range(0, count)
                .mapToObj(i -> PARDIR).toArray(String[]::new);
    }

    private String[] commonPrefix(String[] path1, String[] path2) {
        int minLength = path1.length < path2.length ? path1.length : path2.length;

        ArrayList<String> match = new ArrayList<>();
        for (int i = 0; i < minLength; i++)
            if (!path1[i].equals(path2[i]))
                break;
            else
                match.add(path1[i]);

        return match.toArray(new String[0]);
    }

    public String path() {
        return this.url() + this.appendFragment();
    }

    @Override
    public String toString() {
        return this.path();
    }

}
